name: trigger-all-builds

on:
  workflow_dispatch:
  pull_request:
    branches:
      - main

permissions: {}

jobs:
  trigger-builds:
    name: trigger-all-builds/trigger-builds
    # to be activated before merging this PR
    # if: ${{ startsWith(github.head_ref, 'mergify/merge-queue/') }}
    permissions:
      actions: 'write'
      contents: 'read'
    runs-on: ubuntu-latest
    steps:
      - name: Trigger all build workflows
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const workflows = [
              'test-suite-docker-build.yml'
            ];

            // Determine a valid ref
            let ref;
            if (context.eventName === 'pull_request') {
              const pr = context.payload.pull_request;
              // Skip if from a fork (branch not in this repo)
              if (pr.head.repo.full_name !== `${context.repo.owner}/${context.repo.repo}`) {
                core.warning('PR from fork; skipping dispatch of internal build workflows.');
                return;
              }
              ref = pr.head.ref; // branch name (not refs/heads/…)
            } else {
              // For workflow_dispatch or push use the ref_name
              ref = process.env.GITHUB_REF_NAME || context.ref.replace('refs/heads/','');
            }

            console.log(`Triggering builds using ref: ${ref}`);

            for (const workflow of workflows) {
              console.log(`\nTriggering ${workflow} on ref: ${ref}`);
              
              try {
                const response = await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow,
                  ref: ref,
                  inputs: {
                    ref: ref,
                    trigger_source: 'trigger-all-builds-workflow'
                  }
                });
                
                console.log(`✅ Successfully triggered ${workflow}`);
                console.log(`   Response status: ${response.status}`);
                
              } catch (error) {
                console.log(`❌ Failed to trigger ${workflow}: ${error.message}`);
                console.log('   Error details:', JSON.stringify(error.response?.data || {}, null, 2));
              }
            }
            
            // Wait a moment for workflows to start
            console.log('\n⏳ Waiting 15 seconds for workflows to start...');
            await new Promise(resolve => setTimeout(resolve, 15000));
            
            // Check status of triggered workflows
            console.log('\n📊 Checking status of triggered workflows:');
            for (const workflow of workflows) {
              try {
                const runs = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow,
                  per_page: 3
                });
                
                console.log(`\n${workflow}:`);
                const recentRun = runs.data.workflow_runs.find(run => 
                  run.event === 'workflow_dispatch' && 
                  new Date(run.created_at) > new Date(Date.now() - 300000) // 5 minutes
                );
                
                if (recentRun) {
                  console.log(`   ✅ Found triggered run: ${recentRun.html_url}`);
                  console.log(`   Status: ${recentRun.status} | Conclusion: ${recentRun.conclusion || 'running'}`);
                } else {
                  console.log('   ⚠️ No recent workflow_dispatch run found');
                }
              } catch (error) {
                console.log(`   ❌ Failed to check ${workflow}: ${error.message}`);
              }
            }

  collect-results:
    name: trigger-all-builds/collect-results
    needs: trigger-builds
    # to be activated before merging this PR
    # if: ${{ startsWith(github.head_ref, 'mergify/merge-queue/') }}
    permissions:
      actions: 'read'
      contents: 'read'
      repository-projects: 'write'  # Required for repository_dispatch
    runs-on: ubuntu-latest
    outputs:
      built-images: ${{ steps.collect.outputs.built-images }}
      image-tag: ${{ steps.collect.outputs.image-tag }}
    steps:
      - name: Wait for builds to complete and collect results
        id: collect
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          commit_sha="${{ github.sha }}"
          image_tag="${commit_sha:0:7}"
          echo "image-tag=${image_tag}" >> $GITHUB_OUTPUT
          
          # Map workflow names to image names
          declare -A workflow_to_image
          workflow_to_image["test-suite-docker-build"]="test_suite_version"
          
          # Wait for all workflows to complete and collect built images
          max_attempts=60
          attempt=1
          built_images=()
          
          echo "Looking for workflow_dispatch triggered runs (not specific commit SHA)"
          
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt/$max_attempts: Checking workflow results"
            all_done=true
            current_built_images=()
            
            for workflow_name in "${!workflow_to_image[@]}"; do
              echo "Checking workflow: ${workflow_name}"
              
              # Look for recent workflow_dispatch runs (last 30 minutes)
              since_time=$(date -u -d '30 minutes ago' '+%Y-%m-%dT%H:%M:%SZ')
              run_info=$(gh api \
                "repos/${{ github.repository }}/actions/workflows/${workflow_name}.yml/runs?created=>=${since_time}" \
                --jq '.workflow_runs[] | select(.event == "workflow_dispatch") | {conclusion, id, status, created_at}' \
                | head -1)
              
              if [[ -n "$run_info" ]]; then
                conclusion=$(echo "$run_info" | jq -r '.conclusion')
                status=$(echo "$run_info" | jq -r '.status')
                run_id=$(echo "$run_info" | jq -r '.id')
                created_at=$(echo "$run_info" | jq -r '.created_at')
                
                echo "   Found workflow_dispatch run: ID=${run_id}, Status=${status}, Conclusion=${conclusion:-null}"
                
                if [[ "$conclusion" == "success" ]]; then
                  # Check if the build actually happened by looking for docker jobs
                  jobs_data=$(gh api "repos/${{ github.repository }}/actions/runs/${run_id}/jobs")
                  docker_jobs=$(echo "$jobs_data" | jq -r '.jobs[] | select(.name | contains("docker")) | .conclusion')
                  
                  if [[ -n "$docker_jobs" ]]; then
                    # Count successful docker jobs
                    success_count=$(echo "$docker_jobs" | grep -c "success" || true)
                    if [[ "$success_count" -gt 0 ]]; then
                      image_name="${workflow_to_image[$workflow_name]}"
                      current_built_images+=("${image_name}")
                      echo "   ✅ ${workflow_name} built image: ${image_name} (${success_count} docker jobs succeeded)"
                    else
                      echo "   🔶 ${workflow_name} completed but no docker jobs succeeded"
                    fi
                  else
                    echo "   🔶 ${workflow_name} completed but no docker jobs found"
                  fi
                elif [[ "$conclusion" == "failure" || "$conclusion" == "cancelled" ]]; then
                  echo "   ❌ ${workflow_name} failed with conclusion: ${conclusion}"
                elif [[ "$status" == "in_progress" || "$status" == "queued" || "$conclusion" == "null" ]]; then
                  echo "   ⏳ ${workflow_name} still running (status: ${status})"
                  all_done=false
                fi
              else
                echo "   ⚠️ No recent workflow_dispatch run found for ${workflow_name}"
                all_done=false
              fi
            done
            
            if [ "$all_done" = true ]; then
              built_images=("${current_built_images[@]}")
              break
            fi
            
            echo "Not all workflows complete yet, waiting 30 seconds..."
            sleep 30
            attempt=$((attempt + 1))
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "⚠️ Timeout waiting for all workflows to complete, using current results"
            built_images=("${current_built_images[@]}")
          fi
          
          # Remove duplicates and create JSON array - COMPACT FORMAT
          unique_images=($(printf "%s\n" "${built_images[@]}" | sort -u))
          json_array=$(printf '%s\n' "${unique_images[@]}" | jq -R . | jq -s -c .)
          
          echo "built-images=${json_array}" >> $GITHUB_OUTPUT
          echo "Final built images: ${json_array}"
          
      - name: Trigger test-suite-e2e-tests-orchestrate workflow
        if: success()
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Get the results from the previous step
            const builtImages = '${{ steps.collect.outputs.built-images }}';
            const imageTag = '${{ steps.collect.outputs.image-tag }}';
            
            console.log('🚀 Triggering test-suite-e2e-tests-orchestrate via repository_dispatch');
            console.log(`Built images: ${builtImages}`);
            console.log(`Image tag: ${imageTag}`);
            
            try {
              await github.rest.repos.createDispatchEvent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                event_type: 'test-suite-e2e-tests-orchestrate',
                client_payload: {
                  trigger_run_id: context.runId,
                  head_sha: context.sha,
                  head_branch: process.env.GITHUB_REF_NAME || context.ref.replace('refs/heads/',''),
                  built_images: builtImages,
                  image_tag: imageTag,
                  conclusion: 'success'
                }
              });
              
              console.log('✅ Successfully triggered test-suite-e2e-tests-orchestrate');
            } catch (error) {
              console.log('❌ Failed to trigger test-suite-e2e-tests-orchestrate:', error.message);
              
              // If repository_dispatch fails, try using a different approach
              console.log('🔄 Attempting fallback: direct workflow dispatch');
              
              try {
                await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'test-suite-e2e-tests-orchestrate.yml',
                  ref: process.env.GITHUB_REF_NAME || context.ref.replace('refs/heads/',''),
                  inputs: {
                    built_images: builtImages,
                    image_tag: imageTag,
                    head_branch: process.env.GITHUB_REF_NAME || context.ref.replace('refs/heads/','')
                  }
                });
                
                console.log('✅ Successfully triggered via workflow_dispatch fallback');
              } catch (fallbackError) {
                console.log('❌ Fallback also failed:', fallbackError.message);
                core.setFailed('Both repository_dispatch and workflow_dispatch failed');
              }
            }
